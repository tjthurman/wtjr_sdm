// set up a simple neutral nonWF simulation
initialize() {
	
	// Set up some constants when running interactively,
	// will be able to run in Snakemake in the future
	
	// Will do the phenotypic scale in terms of brown.
	// This is the opposite of the linear models in the text.
	// In the text, higher PC1 == more white,
	// and the linear models in S11 have positive Betas (for the
	// effects of the white allele on PC1).
	
	// For this, I will flip it: 
	// higher PC scores and more alleles == more brown
	// I linearly re-scale the PC scores into 
	// a 0-1 interval, based on the min-max of the average PC1 score
	// across genotype categories (Fig 2F) (rescale -6 to 4 into 0 to 1). 
	if (exists("slimgui"))
	{
		defineConstant("K", 100);	// carrying capacity
		defineConstant("initFreqCorin", 0.95); // initial Corin brown allele frequency
		defineConstant("initFreqEDNRB", 0.98); // initial EDNRB brown allele frequency
		defineConstant("initPopSize", 5000); // initial population size
		defineConstant("initOptPheno", 0.26); // initial optimum phenotype on 0-1 scale
		defineConstant("finalOptPheno", 1); //final optimum phenotype on 0-1 scale
		defineConstant("generations", 2000); //generations to simulate
		defineConstant("fitFuncWidth", 0.9); // SD of fitness function, normal dist
		defineConstant("phenoPCMin", -6.48); // Minimum PC1 phenotype score allowed
		defineConstant("phenoPCMax", 3.66); // Maximum PC1 phenotype score allowed
		defineConstant("h2", 0.64); // target heritability for color. 
	}

	initializeSLiMModelType("nonWF");
	
	// Neutral mutation type.
	// Not sure we actually need this.
	// But we set the mutation rate to 0, so doesn't really matter anyway.
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeGenomicElementType("g1", m1, 1.0);
	m1.convertToSubstitution = T;
		
	// mutations representing alleles in QTLs
	// Simple addivity, with a fixed effect of 1
	initializeMutationType("m2", 0.5, "f", 1);
	initializeGenomicElementType("g2", m2, 1.0);
	
		// Simple addivity, with a fixed effect of 1
	initializeMutationType("m3", 0.5, "f", 1);
	initializeGenomicElementType("g3", m3, 1.0);
	
	// Set up our "chromosome"
	// Really, just doing a two-locus model. Need them to be unlinked.
	// Will add some empty space to ease visualization
	initializeGenomicElement(g1, 0, 99);
	initializeGenomicElement(g2, 100, 100); // First one is corin
	initializeGenomicElement(g1, 101, 199);
	initializeGenomicElement(g3, 200, 200); // second one is ednrb
	initializeGenomicElement(g1, 201, 299);
	
	// Define mutation and recombination rates
	// No mutation
	initializeMutationRate(0);
	// No recombination through most of the chromosome,
	// recombination of 0.5 halfway between the two genes to make them independent
	initializeRecombinationRate(rates = c(0, 0.5, 0), ends = c(149, 150, 299));
}

// each individual reproduces itself once
reproduction() {
	subpop.addCrossed(individual, subpop.sampleIndividuals(1));
}

// m2 and m3 mutations have no direct effects on fitness, all done through phenotypes 
fitness(m2) { return 1.0; } 
fitness(m3) { return 1.0; }

// create an initial population of 10 individuals
1 early() {
	sim.addSubpop("p1", initPopSize);
	print(paste("gen", "opt", "mean_pheno", "mean_dev", "mean_adapt", "mean_pheno_PC", "freq_br_corin", "freq_br_ednrb"));
}

1 late() {
// Add "brown" alleles at a starting frequency of 50% at each locus
corinTargets = sample(p1.genomes, asInteger(length(p1.genomes)*initFreqCorin));
corinTargets.addNewDrawnMutation(m2, 100);

ednrbTargets = sample(p1.genomes, asInteger(length(p1.genomes)*initFreqEDNRB));
ednrbTargets.addNewDrawnMutation(m3, 200);

	// Reschedule the end of the simulation
	sim.rescheduleScriptBlock(s2, start = generations, end = generations);
}

early() {
	// Get phenotype from genotype
	inds = sim.subpopulations.individuals;
	add_pheno_PC = -6.48 + 1.92*inds.sumOfMutationsOfType(m2) + 3.15*inds.sumOfMutationsOfType(m3); // Use lm to get additive phenotype, in PC terms
	
	// Two ways to add in environmental noise.
	// One is to just add in raw environmental noise
	// noise_pheno_PC = rnorm(length(inds), 0, 1);
	// Would need to figure out an appropriate value for the SD there. 
	
	// The other is to target a certain heritability value.
	// This is taken from section 13.4 in the SLiM manual
	// In our case, we could try PVE of 64%
	V_A = var(add_pheno_PC);
	V_E=(V_A-h2*V_A)/h2; //from h2==V_A/(V_A+V_E) 
	noise_pheno_PC = rnorm(size(inds), 0.0, sqrt(V_E));

	// Either way, add them together 	
	phenos_PC = add_pheno_PC + noise_pheno_PC; // Add phenotype with noise to get final phenotype, on PC scale. 
	
	// Then, need to rescale between 0 and 1. 
	// The initial way I did this was just to truncate the recales phenos to between 0 and 1, but that
	// messed with heritability.
	// Now, I'm using the observed min/max breeding values as t he min and max,
	// but will set a new min/max each generation if any individuals fall outside that range. 
	
	rescaleMin = phenoPCMin;
	rescaleMax = phenoPCMax;
	
	if (min(phenos_PC) < phenoPCMin) rescaleMin = min(phenos_PC); 
	if (max(phenos_PC) > phenoPCMax) rescaleMax = max(phenos_PC); 
	
	// may be better to do the scaling the other way: rescale the 0 to 1 from the PC min to PC max????
	phenos_01 = (phenos_PC - rescaleMin)/(phenoPCMax - rescaleMin); // rescale the PC phenos to be between 0 and 1, like the GLMs. 
	
	// COULD DO SOME PLOTTING OF THIS AS A HISTOGRAM OR DENSITY PLOT: DO WE ACTUALLY GET CONtINUOUS VARIATION. 
	
	
	// But, now we can calculate the realized heritability
	obs_h2 = V_A/var(phenos_PC);
	
	// Get optimal phenotype, based on generation
	
	
	// Get individual fitnesses, based on individual phenotype and optimal phenotype
	
	//optimum = initOptPheno + (finalOptPheno - initOptPheno)/generations*sim.generation;
	optimum = 1; 
	deviations = optimum - phenos_01;
	fitnessFunctionMax = dnorm(0.0, 0.0, fitFuncWidth);
	adaptation = dnorm(deviations, 0.0, fitFuncWidth) / fitnessFunctionMax; // WORK ON THIS
	inds.fitnessScaling = adaptation; // WORK ON THIS
	inds.tagF = phenos_01;   // just for output below
	
	// simple density dependence
	p1.fitnessScaling = K / p1.individualCount;	
	
	
	// print out a bunch of metrics 
	print(paste(sim.generation, optimum, mean(inds.tagF), mean(phenos_PC), V_A, V_E, obs_h2, sum(inds.countOfMutationsOfType(m2))/length(p1.genomes), sum(inds.countOfMutationsOfType(m3))/length(p1.genomes)));
	
	
}

s2 999 late() {

	sim.simulationFinished();
}