// set up a simple neutral nonWF simulation
initialize() {
	initializeSLiMModelType("nonWF");
	defineConstant("K", 5000);	// carrying capacity
	
	// Neutral mutation type.
	// Not sure we actually need this.
	// But we set the mutation rate to 0, so doesn't really matter anyway.
	initializeMutationType("m1", 0.5, "f", 0.0);
	initializeGenomicElementType("g1", m1, 1.0);
	m1.convertToSubstitution = T;
		
	// mutations representing alleles in QTLs
	// Simple addivity, with a fixed effect of 1
	initializeMutationType("m2", 0.5, "f", 1);
	initializeGenomicElementType("g2", m2, 1.0);
	
		// Simple addivity, with a fixed effect of 1
	initializeMutationType("m3", 0.5, "f", 1);
	initializeGenomicElementType("g3", m3, 1.0);
	
	// Set up our "chromosome"
	// Really, just doing a two-locus model. Need them to be unlinked.
	// Will add some empty space to ease visualization
	initializeGenomicElement(g1, 0, 99);
	initializeGenomicElement(g2, 100, 100); // First one is corin
	initializeGenomicElement(g1, 101, 199);
	initializeGenomicElement(g3, 200, 200); // second one is ednrb
	initializeGenomicElement(g1, 201, 299);
	
	// Define mutation and recombination rates
	// No mutation
	initializeMutationRate(0);
	// No recombination through most of the chromosome,
	// recombination of 0.5 halfway between the two genes to make them independent
	initializeRecombinationRate(rates = c(0, 0.5, 0), ends = c(149, 150, 299));
}

// each individual reproduces itself once
reproduction() {
	subpop.addCrossed(individual, subpop.sampleIndividuals(1));
}

// create an initial population of 10 individuals
1 early() {
	sim.addSubpop("p1", 5000);
}

1 late() {
// Add "brown" alleles at a starting frequency of 50% at each locus
corinTargets = sample(p1.genomes, 5000);
corinTargets.addNewDrawnMutation(m2, 100);

ednrbTargets = sample(p1.genomes, 5000);
ednrbTargets.addNewDrawnMutation(m3, 200);
}

early() {
	// QTL-based fitness
	inds = sim.subpopulations.individuals;
	phenotypes = 3.69 - 1.84*inds.sumOfMutationsOfType(m2) - 3.14*inds.sumOfMutationsOfType(m3);
	optimum = sim.generation*0.005;
	deviations = optimum - phenotypes;
	fitnessFunctionMax = dnorm(0.0, 0.0, 5.0);
	adaptation = dnorm(deviations, 0.0, 5.0) / fitnessFunctionMax;
	inds.fitnessScaling = 0.1 + adaptation * 0.9;
	inds.tagF = phenotypes;   // just for output below
	
	// density-dependence with a maximum benefit at low density
	p1.fitnessScaling = K / p1.individualCount;
}
fitness(m2) { return 1.0; }


// output all fixed mutations at end
2000 late() { sim.outputFixedMutations(); }
